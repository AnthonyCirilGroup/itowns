<!-- Read CUBEMAP -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - materials - dynamic cube reflection</title>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
        />
    </head>
    <body>
        <!-- Import maps polyfill -->
        <!-- Remove this when import maps will be widely supported -->

        <!-- Import iTowns source code -->
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <!-- Import iTowns Widgets plugin -->
        <script src="../dist/itowns_widgets.js"></script>
        <!-- Import iTowns LoadingScreen and GuiTools plugins -->
        <script src="js/GUI/GuiTools.js"></script>
        <script src="js/GUI/LoadingScreen.js"></script>
        <script src="../jszip/dist/jszip.min.js"></script>
        <script src="../FileSaver/dist/FileSaver.min.js"></script>
        <script>
            let THREE = itowns.THREE;
        </script>
        <script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>

        <script>
            let OrbitControls = itowns.THREE.OrbitControls;
            // let THREE = itowns.THREE;

            // import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
            // import { RGBMLoader } from "three/addons/loaders/RGBMLoader.js";

            let camera, scene, renderer, stats;
            let cube, sphere, torus, material;

            let cubeCamera, cubeRenderTarget;

            let controls;

            init();

            function init() {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setAnimationLoop(animation);
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(renderer.domElement);

                window.addEventListener("resize", onWindowResized);

                camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    1,
                    1000
                );
                camera.position.z = 75;

                scene = new THREE.Scene();
                scene.rotation.y = 0.5; // avoid flying objects occluding the sun

                // new RGBELoader()
                // 	.setPath("textures/equirectangular/")
                // 	.load("quarry_01_1k.hdr", function (texture) {
                // 		texture.mapping = THREE.EquirectangularReflectionMapping;

                // 		scene.background = texture;
                // 		scene.environment = texture;
                // 	});

                //

                const rgbmUrls = [
                    "px.png",
                    "nx.png",
                    "py.png",
                    "ny.png",
                    "pz.png",
                    "nz.png",
                ];

                // const rgbmUrls = [
                // 	"nx.png",
                // 	"px.png",
                // 	"py.png",
                // 	"ny.png",
                // 	"nz.png",
                // 	"pz.png",
                // ];
                // const texture = new RGBMLoader()
                // 	.setMaxRange(16)
                // 	.setPath("./textures/cube/pisaRGBM16/")
                // 	.loadCubemap(rgbmUrls);

                // 				var toulouse_airport_nvg =  new THREE.CubeTextureLoader()
                // .setPath('cubemap/Pau - SD/'+ prefix)

                // const texture = new RGBMLoader()
                // 	.setMaxRange(16)
                // 	.setPath("../cubemappng/")
                // 	.loadCubemap(rgbmUrls);

                const texture = new THREE.CubeTextureLoader()
                    .setPath("./cubemaps/cubemappngWork/")
                    .load([
                        "px.png",
                        "nx.png",
                        "ny.png",
                        "py.png",
                        "pz.png",
                        "nz.png",
                    ]);

                // .load(["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]);

                texture.name = "pisaRGBM16";
                // texture.minFilter = THREE.LinearMipmapLinearFilter;
                // texture.magFilter = THREE.LinearFilter;

                scene.background = texture;
                scene.environment = texture;

                // cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
                cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);

                cubeRenderTarget.texture.type = THREE.HalfFloatType;

                cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);

                //

                material = new THREE.MeshStandardMaterial({
                    envMap: cubeRenderTarget.texture,
                    roughness: 0.05,
                    metalness: 1,
                });

                // const gui = new GUI();
                // gui.add(material, "roughness", 0, 1);
                // gui.add(material, "metalness", 0, 1);
                // gui.add(renderer, "toneMappingExposure", 0, 2).name("exposure");

                sphere = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(15, 8),
                    material
                );
                scene.add(sphere);

                const material2 = new THREE.MeshStandardMaterial({
                    roughness: 0.1,
                    metalness: 0,
                });

                cube = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 15, 15),
                    material2
                );
                scene.add(cube);

                torus = new THREE.Mesh(
                    new THREE.TorusKnotGeometry(8, 3, 128, 16),
                    material2
                );
                scene.add(torus);

                //

                controls = new OrbitControls(camera, renderer.domElement);
                // controls.autoRotate = true;
            }

            function onWindowResized() {
                renderer.setSize(window.innerWidth, window.innerHeight);

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }

            function animation(msTime) {
                const time = msTime / 1000;

                cube.position.x = Math.cos(time) * 30;
                cube.position.y = Math.sin(time) * 30;
                cube.position.z = Math.sin(time) * 30;

                cube.rotation.x += 0.02;
                cube.rotation.y += 0.03;

                torus.position.x = Math.cos(time + 10) * 30;
                torus.position.y = Math.sin(time + 10) * 30;
                torus.position.z = Math.sin(time + 10) * 30;

                torus.rotation.x += 0.02;
                torus.rotation.y += 0.03;

                cubeCamera.update(renderer, scene);

                controls.update();

                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>
