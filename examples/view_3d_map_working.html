<html>
    <head>
        <title>Itowns - Globe</title>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <link rel="stylesheet" type="text/css" href="css/example.css" />
        <link rel="stylesheet" type="text/css" href="css/LoadingScreen.css" />
        <link rel="stylesheet" type="text/css" href="css/widgets.css" />

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    </head>

    <body>
        <div id="viewerDiv"></div>
        <button
            style="bottom: 0px; position: absolute; right: 0; z-index: 1"
            id="savebtn"
        >
            SAVE
        </button>
        <button
            style="bottom: 0px; position: absolute; left: 0; z-index: 1"
            id="rotate"
        >
            Rotate
        </button>

        <button
            style="bottom: 0px; position: absolute; left: 50%; z-index: 1"
            id="screen"
        >
            screen
        </button>

        <!-- Import iTowns source code -->
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <!-- Import iTowns Widgets plugin -->
        <script src="../dist/itowns_widgets.js"></script>
        <!-- Import iTowns LoadingScreen and GuiTools plugins -->
        <script src="js/GUI/GuiTools.js"></script>
        <script src="js/GUI/LoadingScreen.js"></script>
        <script src="../jszip/dist/jszip.min.js"></script>
        <script src="../FileSaver/dist/FileSaver.min.js"></script>
        <script>
            let THREE = itowns.THREE;
        </script>
        <script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>

        <script>
            let OrbitControls = itowns.THREE.OrbitControls;
            // let THREE = itowns.THREE;
            let container, stats, controls;

            let camera, scene, renderer;
            var faces = ["nx", "nz", "px", "ny", "py", "pz"];

            var zip = new JSZip();
            // const rotations = [
            //     [new THREE.Vector3(0, 1, 0), -Math.PI / 2], //px
            //     [new THREE.Vector3(1, 0, 0), -Math.PI / 2], //ny
            //     [new THREE.Vector3(0, 1, 0), Math.PI], //nz
            //     [new THREE.Vector3(0, 1, 0), Math.PI / 2], //nx
            //     [new THREE.Vector3(1, 0, 0), Math.PI / 2], //py
            //     [new THREE.Vector3(0, 0, 0), 0], //pz
            // ];

            const rotations = [
                [new THREE.Vector3(0, 1, 0), -Math.PI / 2], //droite    nx
                [new THREE.Vector3(0, 1, 0), Math.PI], //derriere   nz
                [new THREE.Vector3(0, 1, 0), Math.PI / 2], //gauche px

                [new THREE.Vector3(1, 0, 0), -Math.PI / 2], //bas   ny
                [new THREE.Vector3(1, 0, 0), Math.PI / 2], //haut   py

                [new THREE.Vector3(0, 0, 0), 0], //face pz
            ];

            // const rotations = [
            //     [new THREE.Vector3(0, 0, 1), -Math.PI / 2], //px
            //     [new THREE.Vector3(0, 0, 1), Math.PI], //nz
            //     [new THREE.Vector3(0, 0, 1), Math.PI / 2], //nx
            //     [new THREE.Vector3(1, 0, 0), -Math.PI / 2], //ny

            //     [new THREE.Vector3(1, 0, 0), Math.PI / 2], //py
            //     [new THREE.Vector3(0, 0, 0), 0], //pz
            // ];
            // ---------- CREATE A GlobeView FOR SUPPORTING DATA VISUALIZATION : ----------

            // Define camera initial position
            // const placement = {
            //     coord: new itowns.Coordinates('EPSG:4326', 2.351323, 48.856712),
            //     range: 25000000,
            // }

            var placement = {
                //     coord: new itowns.Coordinates('EPSG:4326', 2.351323, 48.856712),
                coord: new itowns.Coordinates("EPSG:4326", 4.857574, 45.765613),
                // heading: 45,
                range: 1800,
                tilt: 30,
            };
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            const viewerDiv = document.getElementById("viewerDiv");

            // Create a GlobeView
            const view = new itowns.GlobeView(viewerDiv, placement);

            // Setup loading screen and debug menu
            setupLoadingScreen(viewerDiv, view);
            const debugMenu = new GuiTools("menuDiv", view);

            // ---------- DISPLAY ORTHO-IMAGES : ----------

            // Add one imagery layer to the scene. This layer's properties are defined in a json file, but it could be
            // defined as a plain js object. See `Layer` documentation for more info.
            itowns.Fetcher.json("./layers/JSONLayers/Ortho.json").then(
                function _(config) {
                    config.source = new itowns.WMTSSource(config.source);
                    view.addLayer(new itowns.ColorLayer("Ortho", config)).then(
                        debugMenu.addLayerGUI.bind(debugMenu)
                    );
                }
            );

            // ---------- DISPLAY A DIGITAL ELEVATION MODEL : ----------

            // Add two elevation layers, each with a different level of detail. Here again, each layer's properties are
            // defined in a json file.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(
                    new itowns.ElevationLayer(config.id, config)
                ).then(debugMenu.addLayerGUI.bind(debugMenu));
            }
            itowns.Fetcher.json(
                "./layers/JSONLayers/IGN_MNT_HIGHRES.json"
            ).then(addElevationLayerFromConfig);
            itowns.Fetcher.json("./layers/JSONLayers/WORLD_DTM.json").then(
                addElevationLayerFromConfig
            );

            // ---------- ADD SOME WIDGETS : ----------

            // ADD A SCALE :
            const scale = new itowns_widgets.Scale(view, {
                position: "bottom-right",
                translate: { x: -80 },
            });

            // ADD A MINIMAP :
            // const minimap = new itowns_widgets.Minimap(
            //     view,
            //     new itowns.ColorLayer("minimap", {
            //         source: new itowns.VectorTilesSource({
            //             style: "https://wxs.ign.fr/essentiels/static/vectorTiles/styles/PLAN.IGN/gris.json",
            //             // We don't display mountains and plot related data to ease visualisation
            //             filter: (layer) =>
            //                 !layer["source-layer"].includes("oro_") &&
            //                 !layer["source-layer"].includes("parcellaire"),
            //         }),
            //         addLabelLayer: { performance: true },
            //     }),
            //     { cursor: "+" }
            // );

            // ADD NAVIGATION TOOLS :
            const navigation = new itowns_widgets.Navigation(view, {
                position: "bottom-right",
                translate: { y: -40 },
            });

            // // ADD A SEARCH BAR :

            // // You can find more precise explanation on searchbar options in the doc
            // // (http://www.itowns-project.org/itowns/docs/#api/Widgets/Searchbar) and in the searchbar example
            // // (https://www.itowns-project.org/itowns/examples/#widgets_searchbar)

            // // Define options for geocoding service that should be used by the searchbar.
            // const geocodingOptions = {
            //     url: new URL(
            //         "https://wxs.ign.fr/ayxvok72rcocdyn8xyvy32og/ols/apis/completion?text=&type=StreetAddress," +
            //             "PositionOfInterest"
            //     ),
            //     parser: (response) => {
            //         const map = new Map();
            //         response.results.forEach((location) => {
            //             map.set(
            //                 location.fulltext,
            //                 new itowns.Coordinates(
            //                     "EPSG:4326",
            //                     location.x,
            //                     location.y
            //                 )
            //             );
            //         });
            //         return map;
            //     },
            //     onSelected: (coordinates) => {
            //         view.controls.lookAtCoordinate({
            //             coord: coordinates,
            //             range: 20000,
            //             tilt: 45,
            //             heading: 0,
            //         });
            //     },
            // };

            // // Create the searchbar
            // const searchbar = new itowns_widgets.Searchbar(
            //     view,
            //     geocodingOptions,
            //     {
            //         maxSuggestionNumber: 15,
            //         placeholder: "Search a location in France",
            //         position: "top-right",
            //     }
            // );

            // ---------- DISPLAY ATMOSPHERIC LIGHTING : ----------

            const atmosphere = view.getLayerById("atmosphere");
            atmosphere.setRealisticOn(!view.isDebugMode);

            // ---------- DEBUG TOOLS : ----------

            // Toggle atmospheric lighting on/off.
            const cRL = debugMenu.addGUI(
                "RealisticLighting",
                !view.isDebugMode,
                function (v) {
                    atmosphere.setRealisticOn(v);
                    view.notifyChange(atmosphere);
                }
            );

            debug.createTileDebugUI(debugMenu.gui, view);

            // cubemap();
            document.querySelector("#savebtn").addEventListener("click", save);
            document.querySelector("#rotate").addEventListener("click", rotate);
            document.querySelector("#screen").addEventListener("click", screen);
            camera = view.camera.camera3D;
            var g = view.mainLoop.gfxEngine;
            renderer = g.renderer;

            var geometry = new THREE.CylinderGeometry(0, 10, 60, 8);
            var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            var mesh = new THREE.Mesh(geometry, material);
            // get the position on the globe, from the camera
            var cameraTargetPosition = view.controls.getLookAtCoordinate();

            // position of the mesh
            var meshCoord = cameraTargetPosition;
            meshCoord.altitude += 30;

            // position and orientation of the mesh
            mesh.position.copy(meshCoord.as(view.referenceCrs));
            mesh.lookAt(new THREE.Vector3(0, 0, 0));
            mesh.rotateX(Math.PI / 2);

            // update coordinate of the mesh
            mesh.updateMatrixWorld();

            // add the mesh to the scene
            view.scene.add(mesh);

            var meshCoord = new itowns.Coordinates(
                "EPSG:4326",
                2.3372704332298744,
                48.84613800292923,
                896.2812940133736
            );
            meshCoord.altitude += 30;
            var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            var mesh = new THREE.Mesh(geometry, material);

            // position and orientation of the mesh
            mesh.position.copy(meshCoord.as(view.referenceCrs));
            mesh.lookAt(new THREE.Vector3(0, 0, 0));
            mesh.rotateX(Math.PI / 2);

            // update coordinate of the mesh
            mesh.updateMatrixWorld();

            // add the mesh to the scene
            view.scene.add(mesh);

            // make the object usable from outside of the function
            view.mesh1 = mesh;

            var meshCoord = new itowns.Coordinates(
                "EPSG:4326",
                2.331325432744632,
                48.843511044824915,
                0
            );
            meshCoord.altitude += 30;
            var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            var mesh = new THREE.Mesh(geometry, material);

            // position and orientation of the mesh
            mesh.position.copy(meshCoord.as(view.referenceCrs));
            mesh.lookAt(new THREE.Vector3(0, 0, 0));
            mesh.rotateX(Math.PI / 2);

            // update coordinate of the mesh
            mesh.updateMatrixWorld();

            // add the mesh to the scene
            view.scene.add(mesh);

            // make the object usable from outside of the function
            view.mesh2 = mesh;

            var meshCoord = new itowns.Coordinates(
                "EPSG:4326",
                2.335473051885737,
                48.84622153054139,
                946.3335055401549
            );
            meshCoord.altitude += 30;
            var material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            var mesh = new THREE.Mesh(geometry, material);

            // position and orientation of the mesh
            mesh.position.copy(meshCoord.as(view.referenceCrs));
            mesh.lookAt(new THREE.Vector3(0, 0, 0));
            mesh.rotateX(Math.PI / 2);

            // update coordinate of the mesh
            mesh.updateMatrixWorld();

            // add the mesh to the scene
            view.scene.add(mesh);

            // make the object usable from outside of the function
            view.mesh3 = mesh;

            var meshCoord = new itowns.Coordinates(
                "EPSG:4326",
                2.3353434976210523,
                48.8474092641359,
                896.7520226705819
            );
            meshCoord.altitude += 30;
            var material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            var mesh = new THREE.Mesh(geometry, material);

            // position and orientation of the mesh
            mesh.position.copy(meshCoord.as(view.referenceCrs));
            mesh.lookAt(new THREE.Vector3(0, 0, 0));
            mesh.rotateX(Math.PI / 2);

            // update coordinate of the mesh
            mesh.updateMatrixWorld();

            // add the mesh to the scene
            view.scene.add(mesh);

            // make the object usable from outside of the function
            view.mesh3 = mesh;

            view.notifyChange();

            var i = 0;
            var aspect = camera.aspect;
            renderer.setSize(1024, 1024);

            camera.fov = 90;
            camera.aspect = 1.0;
            camera.updateProjectionMatrix();
            renderer.render(view.scene, view.camera.camera3D);
            view.notifyChange(view.camera.camera3D);

            function cubemap() {
                var clientSize = new THREE.Vector2();
                renderer.getSize(clientSize);
                console.log(clientSize);
                var fov = camera.fov;

                // Créer un tableau avec les noms des faces du cubemap
                // var faces = ["px", "nx", "py", "ny", "pz", "nz"];
                // var faces = ["px", "ny", "nz", "nx", "py", "pz"];

                var clientSize = new THREE.Vector2();
                renderer.getSize(clientSize);
                console.log(clientSize);
                var fov = camera.fov;

                var aspect = camera.aspect;
                renderer.setSize(1024, 1024);

                camera.fov = 90;
                camera.aspect = 1.0;
                camera.updateProjectionMatrix();
                renderer.render(view.scene, view.camera.camera3D);
                view.notifyChange(view.camera.camera3D);
                // Parcourir les faces du cubemap
                // for (var i = 0; i < 6; i++) {
                var dataURL = renderer.domElement.toDataURL("image/png");

                // Extraire les données binaires de l'URL
                var data = dataURL.split(",")[1];

                // Ajouter les données binaires au fichier zip avec le nom de la face
                // zip.file(faces[i] + ".png", data, { base64: true });
                if (i > 0) {
                    camera.rotateOnAxis(
                        rotations[i - 1][0],
                        rotations[i - 1][1] * -1.0
                    );
                    // Ajouter les données binaires au fichier zip avec le nom de la face
                    zip.file(faces[i - 1] + ".png", data, { base64: true });
                }

                if (i < 6)
                    camera.rotateOnAxis(rotations[i][0], rotations[i][1]);

                // render();
                renderer.render(view.scene, view.camera.camera3D);
                view.notifyChange(view.camera.camera3D);

                // Récupérer le rendu de la face courante sous forme de données URL
                // var dataURL = renderer.domElement.toDataURL("image/png");

                // // Extraire les données binaires de l'URL
                // var data = dataURL.split(",")[1];

                // // Ajouter les données binaires au fichier zip avec le nom de la face
                // zip.file(faces[i] + ".png", data, { base64: true });
                // }
                // renderer.setSize(clientSize.x, clientSize.y);
                // camera.aspect = aspect;
                // camera.fov = fov;
                // camera.updateProjectionMatrix();

                // renderer.render(view.scene, view.camera.camera3D);
                // view.notifyChange(view.camera.camera3D);
            }

            // Listen for globe full initialisation event
            // LAYERS_INITIALIZED
            // INITIALIZED
            view.addEventListener(
                itowns.VIEW_EVENTS.LAYERS_INITIALIZED,
                function () {
                    // eslint-disable-next-line no-console
                    console.info("Globe initialized");
                }
            );

            // view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
            //     Promise.all(promises).then(function () {
            //         menuGlobe.addImageryLayersGUI(view.getLayers(function (l) { return l.isColorLayer; }));
            //         itowns.ColorLayersOrdering.moveLayerToIndex(view, 'Ortho', 0);
            //     }).catch(console.error);
            // });

            var k = 0;
            function rotate() {
                // if (k > 0)
                //     camera.rotateOnWorldAxis(
                //         rotations[k - 1][0],
                //         rotations[k - 1][1] * -1.0
                //     );
                // camera.rotateOnWorldAxis(rotations[k][0], rotations[k][1]);

                if (k > 0)
                    camera.rotateOnAxis(
                        rotations[k - 1][0],
                        rotations[k - 1][1] * -1.0
                    );
                camera.rotateOnAxis(rotations[k][0], rotations[k][1]);

                // renderer.render(view.scene, view.camera.camera3D);
                view.notifyChange(view.camera.camera3D);
                console.log(view.controls.getLookAtCoordinate());

                // view.camera.camera3D.updateProjectionMatrix();

                k = k == 5 ? 0 : k + 1;
            }
            function save() {
                cubemap();
                if (i == 6) {
                    // Générer le fichier zip et le télécharger
                    zip.generateAsync({ type: "blob" }).then(function (blob) {
                        saveAs(blob, "cubemappng.zip"); // Utiliser la fonction saveAs de FileSaver.js
                    });
                }
                i = i == 6 ? 0 : i + 1;
            }

            function screen() {
                renderer.render(view.scene, view.camera.camera3D);
                view.notifyChange(view.camera.camera3D);
                var dataURL = renderer.domElement.toDataURL("image/png");

                // Extraire les données binaires de l'URL
                var data = dataURL.split(",")[1];

                // Ajouter les données binaires au fichier zip avec le nom de la face
                zip.file("cubemappng.png", data, { base64: true });
                // Générer le fichier zip et le télécharger
                zip.generateAsync({ type: "blob" }).then(function (blob) {
                    saveAs(blob, "screen.zip"); // Utiliser la fonction saveAs de FileSaver.js
                });
            }
        </script>
    </body>
</html>
