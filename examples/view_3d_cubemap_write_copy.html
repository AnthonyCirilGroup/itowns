<!-- WRITE CUBEMAP -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - materials - cube refraction [Lucy]</title>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
        />
        <!-- <link type="text/css" rel="stylesheet" href="main.css" /> -->
    </head>

    <body>
        <button style="bottom: 0px; position: absolute; right: 0" id="savebtn">
            SAVE
        </button>
        <button style="bottom: 0px; position: absolute; left: 0" id="rotate">
            Rotate
        </button>

        <!-- Import iTowns source code -->
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <!-- Import iTowns Widgets plugin -->
        <script src="../dist/itowns_widgets.js"></script>
        <!-- Import iTowns LoadingScreen and GuiTools plugins -->
        <script src="js/GUI/GuiTools.js"></script>
        <script src="js/GUI/LoadingScreen.js"></script>
        <script src="../jszip/dist/jszip.min.js"></script>
        <script src="../FileSaver/dist/FileSaver.min.js"></script>
        <script>
            let THREE = itowns.THREE;
        </script>
        <script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>

        <script>
            let OrbitControls = itowns.THREE.OrbitControls;
            // let THREE = itowns.THREE;
            let container, stats, controls;

            let camera, scene, renderer;

            let pointLight;

            let mouseX = 0,
                mouseY = 0;

            let windowHalfX = window.innerWidth / 2;
            let windowHalfY = window.innerHeight / 2;

            var zip = new JSZip();
            const rotations = [
                [new THREE.Vector3(0, 1, 0), -Math.PI / 2], //px
                [new THREE.Vector3(1, 0, 0), -Math.PI / 2], //ny
                [new THREE.Vector3(0, 1, 0), Math.PI], //nz
                [new THREE.Vector3(0, 1, 0), Math.PI / 2], //nx
                [new THREE.Vector3(1, 0, 0), Math.PI / 2], //py
                [new THREE.Vector3(0, 0, 0), 0], //pz
            ];

            init();
            animate();

            function init() {
                container = document.createElement("div");
                document.body.appendChild(container);

                camera = new THREE.PerspectiveCamera(
                    50,
                    window.innerWidth / window.innerHeight,
                    1,
                    100000
                );
                camera.position.z = -4000;

                //

                const r = "./cubemaps/orginals_park/";

                const urls = [
                    r + "px.jpg",
                    r + "nx.jpg",
                    r + "py.jpg",
                    r + "ny.jpg",
                    r + "pz.jpg",
                    r + "nz.jpg",
                ];

                const textureCube = new THREE.CubeTextureLoader().load(urls);
                textureCube.mapping = THREE.CubeRefractionMapping;

                scene = new THREE.Scene();
                scene.background = textureCube;

                // LIGHTS

                const ambient = new THREE.AmbientLight(0xffffff);
                scene.add(ambient);

                pointLight = new THREE.PointLight(0xffffff, 2);
                scene.add(pointLight);

                // light representation

                const sphere = new THREE.SphereGeometry(100, 16, 8);

                const mesh = new THREE.Mesh(
                    sphere,
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                mesh.scale.set(0.05, 0.05, 0.05);
                pointLight.add(mesh);

                // material samples

                const cubeMaterial3 = new THREE.MeshPhongMaterial({
                    color: 0xccddff,
                    envMap: textureCube,
                    refractionRatio: 0.98,
                    reflectivity: 0.9,
                });
                const cubeMaterial2 = new THREE.MeshPhongMaterial({
                    color: 0xccfffd,
                    envMap: textureCube,
                    refractionRatio: 0.985,
                });
                const cubeMaterial1 = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    envMap: textureCube,
                    refractionRatio: 0.98,
                });

                //

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);

                var clientSize = new THREE.Vector2();
                renderer.getSize(clientSize);
                console.log(clientSize);
                var fov = camera.fov;

                controls = new OrbitControls(camera, renderer.domElement);
                controls.maxPolarAngle = Math.PI * 0.495;
                controls.target.set(0, 10, 0);
                controls.minDistance = 40.0;
                controls.maxDistance = 200.0;
                controls.update();

                // document.addEventListener( 'mousemove', onDocumentMouseMove );

                //

                window.addEventListener("resize", onWindowResize);
            }

            // cubemap();
            document.querySelector("#savebtn").addEventListener("click", save);
            document.querySelector("#rotate").addEventListener("click", rotate);

            function cubemap() {
                var cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
                cubeRenderTarget.texture.type = THREE.HalfFloatType;

                // 		https://forum.babylonjs.com/t/how-to-create-a-cubemap-skybox-from-scene/7421/6
                // 		[new BABYLON.Vector3(0, -Math.PI / 2, 0), new BABYLON.Vector3(-Math.PI / 2, 0, 0), new BABYLON.Vector3(0, Math.PI,0),
                // new BABYLON.Vector3(0, Math.PI / 2, 0), new BABYLON.Vector3(Math.PI / 2, 0, 0), new BABYLON.Vector3(0, 0,0)];

                var cubeCamera = new THREE.CubeCamera(
                    1,
                    1000,
                    cubeRenderTarget
                );

                // Créer une caméra cubemap qui capture les six faces du cube
                // var cubeCamera = new THREE.CubeCamera(0.1, 1000, 512); // Choisir une résolution adaptée
                cubeCamera.position.copy(camera.position); // Placer la caméra cubemap à la position de la caméra
                scene.add(cubeCamera); // Ajouter la caméra cubemap à la scène

                // Rendre la scène avec la caméra cubemap
                cubeCamera.update(renderer, scene);

                // // Créer un fichier zip pour stocker les images jpg
                // var zip = new JSZip();

                // Créer un tableau avec les noms des faces du cubemap
                // var faces = ["px", "nx", "py", "ny", "pz", "nz"];
                var faces = ["px", "ny", "nz", "nx", "py", "pz"];

                // const faces = ['px', 'py', 'pz', 'nx', 'ny', 'nz'];
                var clientSize = new THREE.Vector2();
                renderer.getSize(clientSize);
                console.log(clientSize);
                var fov = camera.fov;

                var aspect = camera.aspect;
                renderer.setSize(1024, 1024);
                camera.fov =
                    2 *
                    THREE.MathUtils.radToDeg(
                        Math.atan(
                            (1024 / clientSize.y) *
                                Math.tan(
                                    THREE.MathUtils.degToRad(camera.fov) / 2
                                )
                        )
                    );
                camera.fov = 90;
                camera.aspect = 1.0;
                camera.updateProjectionMatrix();

                // render();

                // Parcourir les faces du cubemap
                for (var i = 0; i < 6; i++) {
                    if (i > 0)
                        camera.rotateOnWorldAxis(
                            rotations[i - 1][0],
                            rotations[i - 1][1] * -1.0
                        );

                    camera.rotateOnWorldAxis(rotations[i][0], rotations[i][1]);

                    // camera.rotation.set(rotations[i]);
                    render();

                    // Récupérer le rendu de la face courante sous forme de données URL
                    var dataURL = renderer.domElement.toDataURL("image/png");

                    // Extraire les données binaires de l'URL
                    var data = dataURL.split(",")[1];

                    // Ajouter les données binaires au fichier zip avec le nom de la face
                    zip.file(faces[i] + ".png", data, { base64: true });

                    // // Passer à la face suivante en tournant la caméra cubemap de 90 degrés sur l'axe Y
                    // camera.rotateY(Math.PI / 2);

                    // 			const rotations = [new THREE.Vector3(0, -Math.PI / 2, 0), new THREE.Vector3(-Math.PI / 2, 0, 0), new THREE.Vector3(0, Math.PI,0),
                    // new THREE.Vector3(0, Math.PI / 2, 0), new THREE.Vector3(Math.PI / 2, 0, 0), new THREE.Vector3(0, 0,0)];

                    // cubeCamera.rotateX(Math.PI / 2.0);

                    // Rendre la scène avec la caméra cubemap
                    // cubeCamera.update(renderer, scene);
                }
                // camera.rotateOnAxis(rotations[i - 1].multiplyScalar(-1.0));
                renderer.setSize(clientSize.x, clientSize.y);
                camera.aspect = aspect;
                camera.fov = fov;
                camera.updateProjectionMatrix();

                render();

                // // Générer le fichier zip et le télécharger
                // zip.generateAsync({ type: "blob" }).then(function (blob) {
                // 	saveAs(blob, "cubemapjpg.zip"); // Utiliser la fonction saveAs de FileSaver.js
                // });
            }
            var k = 0;
            function rotate() {
                // if (k > 0)
                // 	camera.rotateOnAxis(rotations[k - 1][0], rotations[k - 1][1] * -1.0);

                // camera.rotateOnAxis(rotations[k][0], rotations[k][1]);

                if (k > 0)
                    camera.rotateOnWorldAxis(
                        rotations[k - 1][0],
                        rotations[k - 1][1] * -1.0
                    );

                camera.rotateOnWorldAxis(rotations[k][0], rotations[k][1]);

                // camera.rotation.set(rotations[k]);

                render();
                k = k == 5 ? 0 : k + 1;

                // camera.rotateY(Math.PI / 2);
                // render();
            }
            function save() {
                cubemap();
                // Générer le fichier zip et le télécharger
                zip.generateAsync({ type: "blob" }).then(function (blob) {
                    saveAs(blob, "cubemappng.zip"); // Utiliser la fonction saveAs de FileSaver.js
                });
            }

            function onWindowResize() {
                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function createScene(geometry, m1, m2, m3) {
                geometry.computeVertexNormals();

                const s = 1.5;

                let mesh = new THREE.Mesh(geometry, m1);
                mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
                scene.add(mesh);

                mesh = new THREE.Mesh(geometry, m2);
                mesh.position.x = -1500;
                mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
                scene.add(mesh);

                mesh = new THREE.Mesh(geometry, m3);
                mesh.position.x = 1500;
                mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
                scene.add(mesh);
            }

            function onDocumentMouseMove(event) {
                mouseX = (event.clientX - windowHalfX) * 4;
                mouseY = (event.clientY - windowHalfY) * 4;
            }

            //

            function animate() {
                requestAnimationFrame(animate);

                render();
            }

            function render() {
                const timer = -0.0002 * Date.now();

                // camera.position.x += ( mouseX - camera.position.x ) * .05;
                // camera.position.y += ( - mouseY - camera.position.y ) * .05;

                // camera.lookAt( scene.position );

                pointLight.position.x = 1500 * Math.cos(timer);
                pointLight.position.z = 1500 * Math.sin(timer);

                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>
